import sys, time
from  master import Master
from random import randint
from math import ceil
config(channel is fifo, clock is lamport)
from functools import reduce


class GFSClient(process):
    
    def setup(master:Master):
        output('Setting up client', master)
        self.master = master
        self.temp = None
        self.chunkSize =10
        

    def getNumChunks(size):
        output(size)
        return ceil(float(size)/self.chunkSize)

    def exists(fileName):
        res = None
        output('Searching for file', fileName)
        c = logical_clock()
        send(('FILE_EXISTS_MASTER', fileName, c), to= master)                 # send and await message from master server
        await(some(received(('FILE_EXISTS_MASTER_DONE', res, fileName1, c2)),
                             has= c2 > c and fileName == fileName1))
        #await(self.temp != None)
        output('Hi',res, fileName1)
        return res

    #def receive(msg=('FILE_EXISTS_MASTER_DONE',res), from_=m):
    #    output("received response from master")
    #    self.temp = res

    def receive(msg= ('WRITE_MSG', threadId, fileName, dataToWrite)):
        output('Write file', fileName)
        if(exists(fileName)):
            #send(('DELETE', threadId, fileName))
            await(received(('FILE_DELETED_DONE',)))
        numChunks = self.getNumChunks(len(dataToWrite))
        chunkuuids = []
        c = logical_clock()
        output('Num chunks', numChunks)
        send(('ALLOC_MASTER', threadId, fileName, numChunks, c), to= master)           # send and await message from master server
        await(some(received(('ALLOC_DONE',  pid, fileName1, chunkuuids, c2, chunkServerStore, chunkStore)),
                             has= c2 > c and fileName == fileName1 ))
        self.writeChunks(chunkuuids, dataToWrite, chunkServerStore, chunkStore, fileName)
        send(('WRITTEN',fileName), to=nodeof(self))

    def writeChunks(chunkuuids, dataToWrite, chunkServerStore, chunkStore, fileName):
        output('inside write chunks', chunkStore)
        chunks = [ dataToWrite[x: x+self.chunkSize] for x in range(0, len(dataToWrite), self.chunkSize) ]
        for i in range(0, len(chunkuuids)):
            chunkloc = chunkStore[chunkuuids[i]]
            output(chunkloc, chunkServerStore[chunkloc[0]])
            c= logical_clock()
            chunkServerLocal = []
            chunkLocLength = len(chunkloc)
            for j in range(1, chunkLocLength):
                chunkServerLocal.append(chunkServerStore[chunkloc[j]])
            send(('STORE_DATA', chunkloc[1:], chunkuuids[i], chunks[i],chunkServerLocal, c), to= chunkServerStore[chunkloc[0]])
            await(some(received(('STORE_DATA_DONE', c2, chunkuuid2)),
                             has= c2 > c and chunkuuids[i] == chunkuuid2 ))
            send(('WRITE_CHUNK', chunkuuids[i],chunkloc[1:], chunkServerLocal, c, False), to= chunkServerStore[chunkloc[0]])      # send and await message from chunk server
            output('After send')
            await(some(received(('WRITE_CHUNK_DONE',success, chunkuuid3 , c3)), 
                                    has= c3 > c and chunkuuids[i] == chunkuuid3))   
        send(('UPDATE_LAST_CHUNK_DATA', fileName, chunkuuids[-1], len(chunks[-1])), to= master)  
        
    def receive(msg= ('WRITE_APPEND_MSG', threadId, fileName, dataToWrite)):
        if not self.exists(fileName):
            raise Exception("Append error, file does not exist: " + fileName)
        numChunks = self.getNumChunks(len(dataToWrite))
        toAppend = False
        if((numChunks == 1) and (len(dataToWrite) != self.chunkSize)):
            c = logical_clock()
            send(('GET_LAST_CHUNK_DATA', fileName, c), to= master)
            await(some(received(('GET_LAST_CHUNK_DATA_DONE', fileName1, chunkuuid, currChunkLen, chunkLocList, chunkServerLocal, c3)), 
                                    has= c3 > c and fileName == fileName1))
            if(len(dataToWrite) <= (self.chunkSize - currChunkLen)):
                addToExistingChunkFile(fileName1, chunkuuid, currChunkLen, chunkLocList, chunkServerLocal, dataToWrite)
        else:
            chunkuuids = []
            c = logical_clock()
            output('IN append else')
            send(('ALLOC_APPEND_MASTER', threadId, fileName, numChunks, c), to= master)
            await(some(received(('ALLOC_APPEND_DONE',  pid, fileName1, chunkuuids, c2, chunkServerStore, chunkStore)),
                                 has= c2 > c and fileName == fileName1 ))
            output('After await')
            self.writeChunks(chunkuuids, dataToWrite, chunkServerStore, chunkStore, fileName)

    def addToExistingChunkFile(fileName, chunkuuid, currChunkLen, chunkLocList, chunkServerLocal, dataToWrite):
        output('inside addToExistingChunkFile', chunkuuid)
        c = logical_clock()
        send(('STORE_DATA', chunkLocList[1:], chunkuuid, dataToWrite, chunkServerLocal[1:], c), to= chunkServerLocal[0])
        await(some(received(('STORE_DATA_DONE', c2, chunkuuid2)),
                         has= c2 > c and chunkuuid == chunkuuid2 ))
        send(('WRITE_CHUNK', chunkuuid,chunkLocList[1:], chunkServerLocal[1:], c, True), to= chunkServerLocal[0])      # send and await message from chunk server
        output('After send')
        await(some(received(('WRITE_CHUNK_DONE',success, chunkuuid3 , c3)), 
                                has= c3 > c and chunkuuid == chunkuuid3))   
        send(('UPDATE_LAST_CHUNK_DATA', fileName, chunkuuid, len(dataToWrite)+currChunkLen), to= master)  
        

    def receive(msg= ('READ_MSG', threadId, fileName)):
        if not self.exists(fileName):
            raise Exception("read error, file does not exist: " + fileName)
        chunks = []
        c = logical_clock()
        send(('READ_MASTER', threadId, fileName,c), to= master)
        await(some(received(('READ_MASTER_DONE',  pid, fileName1, c2, chunkServerStore,filetable,chunkStore)),
                             has= c2 > c and fileName == fileName1))
        chunkuuids = filetable[fileName]
        for chunkuuid in chunkuuids:
            c = logical_clock()
            chunkloc = chunkStore[chunkuuid]
            for chunklocation in chunkloc:
                send(('READ_CHUNK',chunkuuid,c), to= chunkServerStore[chunklocation])
            await(some(received(('READ_CHUNK_DONE',chunk,c2)),
                             has= c2 > c ))
            chunks.append(chunk)
        dataRead = reduce(lambda x, y: x+y, chunks)
        send(('READ_FILE_DONE',dataRead,fileName), to=nodeof(self))
        return dataRead

    def receive(msg= ('DELETE', threadId, fileName)):
        c = logical_clock()
        send(('DELETE_FILE_MASTER', threadId, fileName, c), to= master)                         # send and await message from master server
        if await(some(received(('DELETE_FILE_MASTER_DONE', res, fileName1, c2)),
                             has= c2 > c and fileName == fileName1)):
            output('File ', fileName, ' deleted successfully')
        elif timeout(5):
            output('Failed to delete file')
        
    def run():
        #exists('abxc.txt')   
        await(received(('DONE',)))
