import sys, time
from  master import Master
from random import randint
from math import ceil
config(channel is fifo, clock is lamport)
from functools import reduce


class GFSClient(process):
    
    def setup(master:Master):
        output('Setting up client', master)
        self.master = master
        self.temp = None
        self.chunkSize =10
        

    def getNumChunks(size):
        output(size)
        return ceil(float(size)/self.chunkSize)

    def exists(fileName):
        res = None
        output('Searching for file', fileName)
        c = logical_clock()
        send(('FILE_EXISTS_MASTER', fileName, c), to= master)                 # send and await message from master server
        await(some(received(('FILE_EXISTS_MASTER_DONE', res, fileName1, c2)),
                             has= c2 > c and fileName == fileName1))
        return res

    def receive(msg=('CREATE_MSG',threadId,fileName)):
        if(exists(fileName)):        
            output("File exists already",fileName)
            raise Exception("File error, file exists already: " + fileName)  
        output('Create File',fileName)
        numChunks = 1
        chunkuuids = []
        c = logical_clock()
        send(('ALLOC_MASTER', True, fileName, numChunks, c), to= master)           # send and await message from master server
        await(some(received(('ALLOC_DONE', fileName1, chunkuuids, c2, chunkServerStore, chunkStore)),
                             has= c2 > c and fileName == fileName1 ))
        self.writeChunks(chunkuuids,'',chunkServerStore,chunkStore,fileName)
        send(('CREATED',fileName), to=nodeof(self))

    def receive(msg= ('WRITE_MSG', threadId, fileName, dataToWrite)):
        output('Write file', fileName)
        c = logical_clock()
        if not self.exists(fileName):
            raise Exception("File error, file does not exist: " + fileName)
        send(('LATEST_CHUNK_DATA', fileName, c), to= master) 
        await(some(received(('LATEST_CHUNK_DATA_DONE',currentChunkUuid,currChunkLen,chunkuuids,fileName1,c3)), 
                                    has= c3 > c and fileName == fileName1))
        if(currChunkLen == 0 and len(chunkuuids) == 1):        
            numChunks = self.getNumChunks(len(dataToWrite))-1
            chunkuuids = [currentChunkUuid]
            c = logical_clock()
            output('Num chunks', numChunks)
            send(('ALLOC_MASTER', False, fileName, numChunks, c), to= master)           # send and await message from master server
            await(some(received(('ALLOC_DONE', fileName1, chunkuuids, c2, chunkServerStore, chunkStore)),
                                 has= c2 > c and fileName == fileName1 ))
            self.writeChunks(chunkuuids, dataToWrite, chunkServerStore, chunkStore, fileName)
        else:
            raise Exception("File is already writen, use record append: " + fileName)

        send(('WRITTEN',fileName), to=nodeof(self))

    def writeChunks(chunkuuids, dataToWrite, chunkServerStore, chunkStore, fileName):
        output('inside write chunks', chunkStore)
        chunks = [ dataToWrite[x: x+self.chunkSize] for x in range(0, len(dataToWrite), self.chunkSize) ]
        if len(chunks) ==0:
            output(0)
            chunks= [""]
        output(len(chunks[0]))
        for i in range(0, len(chunkuuids)):
            chunkloc = chunkStore[chunkuuids[i]]
            output(chunkloc, chunkServerStore[chunkloc[0]])
            c= logical_clock()
            chunkServerLocal = []
            chunkLocLength = len(chunkloc)
            for j in range(1, chunkLocLength):
                chunkServerLocal.append(chunkServerStore[chunkloc[j]])
            output('till here')
            send(('STORE_DATA', chunkloc[1:], chunkuuids[i], chunks[i],chunkServerLocal, c), to= chunkServerStore[chunkloc[0]])
            await(some(received(('STORE_DATA_DONE', c2, chunkuuid2)),
                             has= c2 > c and chunkuuids[i] == chunkuuid2 ))
            send(('WRITE_CHUNK', chunkuuids[i],chunkloc[1:], chunkServerLocal, c, False), to= chunkServerStore[chunkloc[0]])      # send and await message from chunk server
            output('After send')
            await(some(received(('WRITE_CHUNK_DONE',success, chunkuuid3 , c3)), 
                                    has= c3 > c and chunkuuids[i] == chunkuuid3))   
        send(('UPDATE_LAST_CHUNK_DATA', fileName, chunkuuids[-1], len(chunks[-1])), to= master) 

        
    def receive(msg= ('WRITE_APPEND_MSG', threadId, fileName, dataToWrite)):
        if not self.exists(fileName):
            raise Exception("Append error, file does not exist: " + fileName)
        c = logical_clock()
        send(('ADD_TO_LEASE_Q', fileName, c, 'APPEND'), to= master)
        await(some(received(('CLIENT_TURN_IN_LEASE_Q_APPEND', fileName1, c3)), 
                                has= c3 > c and fileName == fileName1))
        numChunks = self.getNumChunks(len(dataToWrite))
        toAppend = False
        if((numChunks == 1) and (len(dataToWrite) != self.chunkSize)):
            output('In append if')
            c = logical_clock()
            send(('GET_LAST_CHUNK_DATA', fileName, c), to= master)
            await(some(received(('GET_LAST_CHUNK_DATA_DONE', fileName1, chunkuuid, currChunkLen, chunkLocList, chunkServerLocal, c3)), 
                                    has= c3 > c and fileName == fileName1))
            output('After await', dataToWrite, self.chunkSize, currChunkLen)
            if(len(dataToWrite) <= (self.chunkSize - currChunkLen)):
                addToExistingChunkFile(fileName1, chunkuuid, currChunkLen, chunkLocList, chunkServerLocal, dataToWrite)
            else:
                chunkuuids = []
                c = logical_clock()
                output('IN append else')
                send(('ALLOC_APPEND_MASTER', threadId, fileName, numChunks, c), to= master)
                await(some(received(('ALLOC_APPEND_DONE',  pid, fileName1, chunkuuids, c2, chunkServerStore, chunkStore)),
                                     has= c2 > c and fileName == fileName1 ))
                output('After await')
                self.writeChunks(chunkuuids, dataToWrite, chunkServerStore, chunkStore, fileName)
        else:
            chunkuuids = []
            c = logical_clock()
            output('IN append else')
            send(('ALLOC_APPEND_MASTER', threadId, fileName, numChunks, c), to= master)
            await(some(received(('ALLOC_APPEND_DONE',  pid, fileName1, chunkuuids, c2, chunkServerStore, chunkStore)),
                                 has= c2 > c and fileName == fileName1 ))
            output('After await')
            self.writeChunks(chunkuuids, dataToWrite, chunkServerStore, chunkStore, fileName)
        output('DONE WITH RECORD_APPEND ', self)
        c1 = logical_clock()
        send(('PROCESS_NEXT_IN_LEASE_Q', fileName, c1), to= master) 


    def addToExistingChunkFile(fileName, chunkuuid, currChunkLen, chunkLocList, chunkServerLocal, dataToWrite):
        output('inside addToExistingChunkFile', chunkuuid)
        c = logical_clock()
        send(('STORE_DATA', chunkLocList[1:], chunkuuid, dataToWrite, chunkServerLocal[1:], c), to= chunkServerLocal[0])
        await(some(received(('STORE_DATA_DONE', c2, chunkuuid2)),
                         has= c2 > c and chunkuuid == chunkuuid2 ))
        send(('WRITE_CHUNK', chunkuuid,chunkLocList[1:], chunkServerLocal[1:], c, True), to= chunkServerLocal[0])      # send and await message from chunk server
        output('After send')
        await(some(received(('WRITE_CHUNK_DONE',success, chunkuuid3 , c3)), 
                                has= c3 > c and chunkuuid == chunkuuid3))   
        send(('UPDATE_LAST_CHUNK_DATA', fileName, chunkuuid, len(dataToWrite)+currChunkLen), to= master)

        

    def receive(msg= ('READ_MSG', threadId, fileName)):
        if not self.exists(fileName):
            raise Exception("read error, file does not exist: " + fileName)
        chunks = []
        c = logical_clock()
        send(('READ_MASTER', threadId, fileName,c), to= master)
        await(some(received(('READ_MASTER_DONE',  pid, fileName1, c2, chunkServerStore,filetable,chunkStore)),
                             has= c2 > c and fileName == fileName1))
        chunkuuids = filetable[fileName]
        for chunkuuid in chunkuuids:
            c = logical_clock()
            chunkloc = chunkStore[chunkuuid]
            for chunklocation in chunkloc:
                send(('READ_CHUNK',chunkuuid,c), to= chunkServerStore[chunklocation])
            await(some(received(('READ_CHUNK_DONE',chunk,c2)),
                             has= c2 > c ))
            chunks.append(chunk)
        dataRead = reduce(lambda x, y: x+y, chunks)
        send(('READ_FILE_DONE',dataRead,fileName), to=nodeof(self))
        return dataRead

    def receive(msg= ('DELETE', threadId, fileName)):
        c = logical_clock()
        send(('DELETE_FILE_MASTER', threadId, fileName, c), to= master)                         # send and await message from master server
        if await(some(received(('DELETE_FILE_MASTER_DONE', res, fileName1, c2)),
                             has= c2 > c and fileName == fileName1)):
            output('File ', fileName, ' deleted successfully')
        elif timeout(5):
            output('Failed to delete file')

    def receive(msg= ('CREATE_SNAPSHOT', threadId, fileName)):
        if not self.exists(fileName):
            raise Exception("read error, file does not exist: " + fileName)
        c = logical_clock()
        send(('ADD_TO_LEASE_Q', fileName, c, 'SNAPSHOT'), to= master)
        await(some(received(('CLIENT_TURN_IN_LEASE_Q_SNAPSHOT', fileName1, c3)), 
                                has= c3 > c and fileName == fileName1))
        c = logical_clock()
        send(('READ_MASTER', threadId, fileName,c), to= master)
        await(some(received(('READ_MASTER_DONE',  pid, fileName1, c2, chunkServerStore,filetable,chunkStore)),
                             has= c2 > c and fileName == fileName1))
        chunkuuids = filetable[fileName]
        res = True
        for chunkuuid in chunkuuids:
            chunkloc = chunkStore[chunkuuid]
            for chunklocation in chunkloc:
                c = logical_clock()
                send(('WRITE_CHUNK_SNAPSHOT', chunkuuid,c), to=chunkServerStore[chunklocation])
                await(some(received(('WRITE_CHUNK_SNAPSHOT_DONE',chunkuuid,c2, res)),has= c2 > c ))
                if not res:
                    output('SNAPSHOT creation failed')
        
        c = logical_clock()
        if res:
           send(('UPDATE_SNAPSHOT', fileName, c ), to=master) 
           await(some(received(('UPDATE_SNAPSHOT_DONE',fileName, c2)),has= c2 > c ))
        c1 = logical_clock()
        send(('PROCESS_NEXT_IN_LEASE_Q', fileName, c1), to= master) 
        
    def run():
        #exists('abxc.txt')   
        await(received(('DONE',)))
