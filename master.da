"""
Created on Mon Nov 26 18:05:06 2018

@author: risabh
"""

import uuid
from chunk import GFSChunkserver
config(channel is fifo, clock is lamport)

class Master(process):

    def setup():
        output('Setting up Master')
        self.fileStore = {}                 # Maps filename to chunkuuids
        self.chunkStore = {}                # Maps chunkuuids to chunk locations
        self.chunkServerStore = {}          # Maps chunk location to physical server/storage
        self.lastChunkOfFileStore = {}      # Maps every file with last chunkid and length of last chunk
        self.deletedChunksList = []
        self.numChunkServer = 5
        self.chunkSize = 10
        self.counter = 0
        self.res = False
        self.numReplicas = 2
        self.initChunks()
        
    
    def initChunks():
        output('Setting up chunkServer')
        for i in range(0, self.numChunkServer):
            chunkServer = new(GFSChunkserver)
            setup(chunkServer, (i,))
            start(chunkServer)
            self.chunkServerStore[i] = chunkServer
    
    def allocateChunks(numChunks):
        output('Allocating chunks')
        chunkuuids = []
        for i in range(0, numChunks):
            chunkuuid = uuid.uuid4()
            chunkLocation = self.counter
            chunkuuids.append(chunkuuid)
            chunkLocations = [chunkLocation]
            for j in range(0, numReplicas):
                counterTemp = (self.counter+j+1) % self.numChunkServer
                chunkLocations.append(counterTemp)
            self.chunkStore[chunkuuid] = chunkLocations
            self.counter = (self.counter+1) % self.numChunkServer
        return chunkuuids
     
    def receive(msg= ('ALLOC_MASTER', pid, fileName, numChunks, c),from_= client):
        output('Inside master to write', fileName)
        chunkuuids = self.allocate(fileName, numChunks)
        output('In master chunks', chunkuuids)
        send(('ALLOC_DONE', pid, fileName, chunkuuids, c+1, chunkServerStore, chunkStore ), to=client)

    def allocate(fileName, numChunks):
        chunkuuids = self.allocateChunks(numChunks)
        output('Chunks allocated')
        self.fileStore[fileName] = chunkuuids
        return chunkuuids
    
    def receive(msg = ('ALLOC_APPEND_MASTER', pid, fileName, numChunks, c), from_=client):
        chunkuuids = self.allocate_append(fileName, numChunks)
        send(('ALLOC_APPEND_DONE', pid, fileName, chunkuuids, c+1, chunkServerStore, chunkStore ), to=client)


    def receive(msg = ('READ_MASTER', pid, fileName,c), from_=client):
        send(('READ_MASTER_DONE', pid, fileName, c+1, self.chunkServerStore,self.fileStore,self.chunkStore), to=client)          

    
    def allocate_append(fileName, numChunks):
        chunkuuids = self.allocateChunks(numChunks)
        chunkuuids_initial = self.fileStore[fileName]
        chunkuuids_initial.extend(chunkuuids)
        output('Allocate_append', chunkuuids_initial)
        return chunkuuids

    def receive(msg = ('UPDATE_LAST_CHUNK_DATA', fileName, chunkuuid, chunklen), from_=client):
        self.lastChunkOfFileStore[fileName] = [chunkuuid, chunklen]

    def receive(msg = ('GET_LAST_CHUNK_DATA', fileName, c), from_=client):
        chunkuuid = lastChunkOfFileStore[fileName][0]
        currChunkLen = lastChunkOfFileStore[fileName][1]
        chunkLocList = chunkStore[lastChunkOfFileStore[fileName][0]]
        chunkServerLocal = []
        for j in range(0, len(chunkLocList)):
            chunkServerLocal.append(chunkServerStore[chunkLocList[j]])
        send(('GET_LAST_CHUNK_DATA_DONE', fileName, chunkuuid, currChunkLen, chunkLocList, chunkServerLocal, c+1), to= client)

    
    def receive(msg = ('DELETE_FILE_MASTER', pid, fileName), from_=client):
        fileDeleted = delete(fileName)
        if fileDeleted:
            send(('DELETE_FILE_MASTER_DONE', pid, fileName), to=client)
        elif timeout(6):
            pass
        
    def delete(fileName):
        try:
            for i in range(0, len(fileStore[fileName])):
                deletedChunksList.append(fileStore[fileName][i])
            del fileStore[fileName]
            return True
        except:
            output('Error while deleting file')
            return False
            
    def receive(msg =('FILE_EXISTS_MASTER', fileName, c), from_= client):
        self.res = exists(fileName)
        output(res, client)
        send(('FILE_EXISTS_MASTER_DONE', self.res, fileName, c+1), to=client)
        output("RES sent : ", res)
        
    def exists(fileName):
        output('Checking file', fileName)
        if fileName in self.fileStore:
            return True
        return False
        
    def run():
        await(received(('DONE',)))

    

