"""
Created on Mon Nov 26 18:05:06 2018

@author: risabh
"""

from HeartBeat import HeartBeat
import uuid
import time
from random import randint
from chunk import GFSChunkserver
config(channel is fifo, clock is lamport)

class Master(process):

    def setup():
        output('Setting up Master')
        self.fileStore = {}                 # Maps filename to chunkuuids
        self.chunkStore = {}                # Maps chunkuuids to chunk locations
        self.chunkServerStore = {}          # Maps chunk location to physical server/storage
        self.lastChunkOfFileStore = {}      # Maps every file with last chunkid and length of last chunk
        self.deletedChunksList = {}
        self.leaseQueue = {}                # Maps fileName with client requests
        self.numChunkServer = 5
        self.chunkSize = 10
        self.counter = 0
        self.res = False
        self.numReplicas = 3
        self.snapShotuuids ={}
        self.availableChunkServers = set()
        self.nonAvailableChunkServers =set()
        self.tempStore = {}
        self.initChunks()
        
    
    def initChunks():
        output('Setting up chunkServer')
        for i in range(0, self.numChunkServer):
            chunkServer = new(GFSChunkserver)
            setup(chunkServer, (i,))
            start(chunkServer)
            self.chunkServerStore[i] = chunkServer
            self.availableChunkServers.add(chunkServer)
    
    def allocateChunks(numChunks):
        output('Allocating chunks')
        chunkuuids = []
        for i in range(0, numChunks):
            chunkuuid = str(uuid.uuid4())
            chunkLocation = self.counter
            chunkuuids.append(chunkuuid)
            chunkLocations = [chunkLocation]
            j=0
            while len(chunkLocations)<numReplicas:
                counterTemp = (self.counter+j+1) % self.numChunkServer
                j+=1
                if self.chunkServerStore[counterTemp] not in self.nonAvailableChunkServers:
                    chunkLocations.append(counterTemp)
            self.chunkStore[chunkuuid] = chunkLocations
            self.counter = (self.counter+1) % self.numChunkServer
        return chunkuuids
     
    def receive(msg= ('ALLOC_MASTER', isCreate, fileName, numChunks, c),from_= client):
        output('Inside master to allocate', fileName)
        chunkuuids = self.allocate(fileName, numChunks, isCreate)
        send(('ALLOC_DONE', fileName, chunkuuids, c+1, chunkServerStore,
                 chunkStore ), to=client)

    def allocate(fileName, numChunks, isCreate):
        chunkuuids = self.allocateChunks(numChunks)
        self.tempStore[fileName] = chunkuuids
        output('Chunks allocated')
        if not isCreate:
            chunkuuids = self.fileStore[fileName]+ chunkuuids
        self.fileStore[fileName] = chunkuuids
        return chunkuuids
    
    def receive(msg = ('ALLOC_APPEND_MASTER', fileName, numChunks, c), from_=client):
        chunkuuids = self.allocate_append(fileName, numChunks)
        send(('ALLOC_APPEND_DONE', fileName, chunkuuids, c+1,
                 chunkServerStore, chunkStore ), to=client)


    def receive(msg = ('READ_MASTER', fileName,c), from_=client):
        send(('READ_MASTER_DONE', fileName, c+1, 
        self.chunkServerStore, self.fileStore[fileName], self.chunkStore), to=client)          

    
    def allocate_append(fileName, numChunks):
        chunkuuids = self.allocateChunks(numChunks)
        chunkuuids_initial = self.fileStore[fileName]
        chunkuuids_initial.extend(chunkuuids)
        output('Allocate_append', chunkuuids_initial)
        return chunkuuids

    def receive(msg = ('UPDATE_LAST_CHUNK_DATA', fileName, chunkuuid, chunklen), from_=client):
        self.lastChunkOfFileStore[fileName] = [chunkuuid, chunklen]

    def receive(msg = ('LATEST_CHUNK_DATA', fileName, c), from_=client):
        chunkuuid = lastChunkOfFileStore[fileName][0]
        currChunkLen = lastChunkOfFileStore[fileName][1]
        chunkuuids = fileStore[fileName]
        send(('LATEST_CHUNK_DATA_DONE',chunkuuid,currChunkLen,chunkuuids,fileName,c+1), to=client)   

    def receive(msg = ('GET_LAST_CHUNK_DATA', fileName, c), from_=client):
        chunkuuid = lastChunkOfFileStore[fileName][0]
        currChunkLen = lastChunkOfFileStore[fileName][1]
        chunkLocList = chunkStore[lastChunkOfFileStore[fileName][0]]
        chunkServerLocal = []
        for j in range(0, len(chunkLocList)):
            chunkServerLocal.append(chunkServerStore[chunkLocList[j]])
        send(('GET_LAST_CHUNK_DATA_DONE', fileName, chunkuuid, currChunkLen,
             chunkLocList, chunkServerLocal, c+1), to= client)

    
    def receive(msg = ('DELETE_FILE_MASTER', fileName, c), from_=client):
        output('Inside delete File master')
        fileDeleted = delete(fileName)
        if fileDeleted:
            send(('DELETE_FILE_MASTER_DONE', fileName, c+1), to=client)
        else:
            output('Raising exception')
            raise Exception("Error while deleting file "+fileName)  
    
    def delete(fileName):
        try:
            output('In delete')
            addToGarbageList(fileStore[fileName])        
            if fileName in self.snapShotuuids:
                addToGarbageList(self.snapShotuuids[fileName])
                del self.snapShotuuids[fileName]
            del fileStore[fileName]
            return True
        except:
            output('Error while deleting file')
            return False
            
    def receive(msg =('FILE_EXISTS_MASTER', fileName, c), from_= client):
        self.res = exists(fileName)
        output(res, client)
        send(('FILE_EXISTS_MASTER_DONE', self.res, fileName, c+1), to=client)
        output("RES sent : ", res)
        
    def exists(fileName):
        output('Checking file', fileName)
        if fileName in self.fileStore:
            return True
        return False
    
    def receive(msg = ('GET_AVAILABLE_CHUNK_SERVERS', ), from_=heartBeat):
        send(('AVAILABLE_CHUNK_SERVERS',self.availableChunkServers), to = heartBeat)
    
    def receive(msg = ('UPDATE_AVAILABLE_CHUNK_SERVERS', nonAvailableChunkServers), from_= heartBeat):
        self.nonAvailableChunkServers = nonAvailableChunkServers
    
    def receive(msg = ('DELETE_ORPHANED_CHUNKS', fileList), from_=heartBeat):
        localChunkList = {}
        for chunkServer,chunkuuids in self.deletedChunksList.items():
            if chunkServer not in self.nonAvailableChunkServers:
            
                chunkFilesToDelete =[]
                for  chunkuuid in chunkuuids:
                    if chunkuuid in fileList[chunkServer]:
                        chunkFilesToDelete.append(chunkuuid)
                if len(chunkFilesToDelete) != 0:
                    send(('DELETED_CHUNKS', chunkFilesToDelete), to= chunkServer)
                localChunkList[chunkServer] = list(set(chunkuuids) - set(chunkFilesToDelete))
            else:
                localChunkList[chunkServer] = chunkuuids
        self.deletedChunksList = localChunkList
    

    def receive(msg =('ADD_TO_LEASE_Q', fileName, c, operation), from_= client):
        output('Adding to lease Q from client ', client)
        if fileName not in leaseQueue:
            leaseQueue[fileName] = []
        if operation=='SNAPSHOT and len(leaseQueue[fileName])>1':
            output(leaseQueue[fileName])
            leaseQueue[fileName].insert(1,(client,operation,c))
            output(leaseQueue[fileName])
        else:
            leaseQueue[fileName].append((client,operation,c))
        checkQueueAndReturn(fileName, client, c, operation)

    def checkQueueAndReturn(fileName, client, c, operation):
        if leaseQueue[fileName][0][0] == client and leaseQueue[fileName][0][1] == operation:
            output('Chance given to ', client, operation)
            msg  ='CLIENT_TURN_IN_LEASE_Q_'+operation 
            send((msg, fileName, c+1), to= client)
            
        else:
            output('Chance not given to ', client)
            #send(('CLIENT_TURN_IN_LEASE_Q', fileName, c), to= client)

    def receive(msg =('PROCESS_NEXT_IN_LEASE_Q', fileName), from_= client):
        leaseQueue[fileName].pop(0)
        if len(leaseQueue[fileName]) != 0:
            output("Lease for",leaseQueue[fileName][0])
            output("Lease Queue", leaseQueue[fileName])
            checkQueueAndReturn(fileName, leaseQueue[fileName][0][0], leaseQueue[fileName][0][2], leaseQueue[fileName][0][1])
    
    def receive(msg=('UPDATE_SNAPSHOT', fileName, c), from_=client):
        chunkuuids = self.fileStore[fileName]
        if fileName not in self.snapShotuuids:
            self.snapShotuuids[fileName] = []
        self.snapShotuuids[fileName].extend(chunkuuids)
        new_chunkuuids = [chunkuuid+'-SNAPSHOT' for chunkuuid in chunkuuids]
        for chunkuuid in chunkuuids:
            chunkLoc = self.chunkStore[chunkuuid]
            #del self.chunkStore[chunkuuid]
            self.chunkStore[chunkuuid+'-SNAPSHOT'] = chunkLoc
        lastChunkData = lastChunkOfFileStore[fileName]
        lastChunkuuid = lastChunkData[0]+'-SNAPSHOT'
        updatedLastChunk = [lastChunkuuid, lastChunkData[1]] 
        self.lastChunkOfFileStore[fileName] = updatedLastChunk
        self.fileStore[fileName] = new_chunkuuids
        send(('UPDATE_SNAPSHOT_DONE', fileName, c+1), to = client)
    
    def addToGarbageList(chunkuuids):
        for chunkuuid in chunkuuids:
                output(self.chunkStore[chunkuuid])
                for chunkLoc in self.chunkStore[chunkuuid]:
                    if self.chunkServerStore[chunkLoc] not in self.deletedChunksList:
                        self.deletedChunksList[self.chunkServerStore[chunkLoc]] = []
                    self.deletedChunksList[self.chunkServerStore[chunkLoc]].append(chunkuuid)
    
    def receive(msg=('ERROR_CREATE',fileName), from_=client):
        if fileName in self.fileStore:
            addToGarbageList(fileStore[fileName])        
            del self.fileStore[fileName]
            if fileName in self.tempStore:           
                del self.tempStore[fileName] 
    
    def receive(msg=('ERROR_WRITE',fileName), from_=client):
        if fileName in self.fileStore:
            addToGarbageList(fileStore[fileName])
            del self.fileStore[fileName]
            if fileName in self.tempStore[fileName]:           
                del self.tempStore[fileName] 
        output(self.fileStore)
        output(self.tempStore)
    
    def receive(msg=('ERROR_WRITE_APPEND',fileName), from_=client):
        if fileName in self.tempStore:
            addToGarbageList(self.tempStore[fileName])
            for chunkuuid in self.tempStore[fileName]:
                if chunkuuid in self.fileStore[fileName]:
                    self.fileStore[fileName].remove(chunkuuid)           
            del self.tempStore[fileName] 
    
    def receive(msg=('KILL_CHUNKSERVER', c ), from_=client):
        
        id = randint(0, len(self.availableChunkServers))
        output("In master for kill", id)
        send(('KILL_CHUNK',self.chunkServerStore[id], c+1), to= client )
            
    def run():
        heartBeat =  new(HeartBeat)
        setup(heartBeat, (self,))
        start(heartBeat)
        await(received(('DONE',)))

    

